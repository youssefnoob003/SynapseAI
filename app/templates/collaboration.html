{% extends "layout.html" %}

{% block title %}Collaboration Network{% endblock %}

{% block content %}
<div class="container py-4">
    <!-- Network Visualization Card -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card shadow-sm">
                <div class="card-body">
                    <h2 class="card-title h4 mb-4">Team Collaboration Network</h2>
                    <div class="row align-items-center mb-4">
                        <div class="col-md-6">
                            <h6 class="text-muted mb-0">Data for period: <span id="currentPeriod" class="fw-medium"></span></h6>
                        </div>
                        <div class="col-md-6 text-md-end mt-3 mt-md-0">
                            <div class="legend small">
                                <span class="me-3"><i class="bi bi-circle-fill text-primary"></i> Team Member</span>
                                <span><i class="bi bi-arrow-right"></i> Collaboration Strength</span>
                            </div>
                        </div>
                    </div>
                    <div id="networkGraph" style="height: 600px;" class="rounded"></div>
                    
                    <!-- Horizontal date slider -->
                    <div class="mt-4">
                        <div id="dateSliderContainer" class="position-relative">
                            <div id="dateSliderTrack" class="position-relative" style="height: 40px; width: 100%;"></div>
                            <input type="range" class="form-range position-absolute top-50 start-0 end-0" 
                                id="dateSlider" min="0" max="0" value="0" style="transform: translateY(-50%); z-index: 10;">
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Collaboration Details Card -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card shadow-sm">
                <div class="card-body">
                    <h2 class="card-title h4 mb-4">Collaboration Details</h2>
                    <div class="table-responsive">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>From</th>
                                    <th>To</th>
                                    <th>Interaction Count</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody id="collaborationTableBody">
                                <!-- Table rows will be populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<!-- D3.js for network visualization -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<script>
// Pass collaboration data from Flask to JavaScript
const collaborationData = {{ collaboration_data | tojson | safe }};
console.log('Loaded collaboration data:', collaborationData);

// Network visualization configuration
const networkContainer = document.getElementById('networkGraph');
const width = networkContainer.clientWidth || 800; // Fallback if clientWidth is 0
const height = 600;
const nodeRadius = 24; // Slightly smaller for a more modern look
const nodePadding = 5;

// Modern color palette - using a muted, sophisticated palette
const modernPalette = [
    '#264653', // Dark cyan
    '#2a9d8f', // Teal
    '#e9c46a', // Gold
    '#f4a261', // Peach
    '#e76f51', // Terracotta
    '#606c38', // Olive
    '#dda15e', // Camel
    '#bc6c25', // Rust
    '#5f0f40', // Burgundy
    '#0b525b'  // Deep teal
];

// Use a more modern color scale
const colors = d3.scaleOrdinal(modernPalette);

console.log('Container dimensions:', { width, height });

// Initialize the SVG with explicit dimensions
const svg = d3.select('#networkGraph')
    .append('svg')
    .attr('width', '100%')
    .attr('height', height)
    .attr('viewBox', `0 0 ${width} ${height}`)
    .attr('preserveAspectRatio', 'xMidYMid meet');

// Create arrow marker for directed edges
svg.append('defs').append('marker')
    .attr('id', 'arrowhead')
    .attr('viewBox', '-5 -5 10 10')
    .attr('refX', nodeRadius)
    .attr('refY', 0)
    .attr('markerWidth', 6)
    .attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M -5,-5 L 5,0 L -5,5')
    .attr('class', 'arrowhead');

// Create the force simulation with improved centering after repulsion
const simulation = d3.forceSimulation()
    .force('link', d3.forceLink().id(d => d.id).distance(d => 80 + d.value * 2)) // Distance based on link value
    .force('charge', d3.forceManyBody().strength(-400)) 
    .force('center', d3.forceCenter(width / 2, height / 2).strength(0.05)) // Gentler centering force
    .force('x', d3.forceX(width / 2).strength(0.07)) // Additional x-centering force
    .force('y', d3.forceY(height / 2).strength(0.07)) // Additional y-centering force
    .force('collision', d3.forceCollide().radius(nodeRadius * 1.6))
    .alphaDecay(0.01); // Slower decay for more balanced layout

// Text wrapping function for node labels
function wrap(text, width) {
    text.each(function() {
        const text = d3.select(this);
        const words = text.text().split(/\s+/).reverse();
        const lineHeight = 1.1;
        const y = text.attr('y');
        const dy = parseFloat(text.attr('dy'));
        let line = [];
        let lineNumber = 0;
        let tspan = text.text(null).append('tspan').attr('x', 0).attr('y', y).attr('dy', dy + 'em');
        
        let word;
        while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(' '));
            if (line.join(' ').length > 10) {
                line.pop();
                tspan.text(line.join(' '));
                line = [word];
                tspan = text.append('tspan').attr('x', 0).attr('y', y).attr('dy', ++lineNumber * lineHeight + dy + 'em').text(word);
            }
        }
    });
}

// Drag functions
function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
}

function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
}

function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
}

function updateNetwork(monthData) {
    if (!monthData) {
        console.error('No month data available:', monthData);
        return;
    }
    
    console.log('Month data received:', monthData);
    
    // Process the data
    const nodesSet = new Set();
    const nodeLinkCount = new Map(); // Track number of connections for each node
    
    monthData.forEach(link => {
        nodesSet.add(link.from);
        nodesSet.add(link.to);
        
        // Count connections for sizing nodes
        nodeLinkCount.set(link.from, (nodeLinkCount.get(link.from) || 0) + link.count);
        nodeLinkCount.set(link.to, (nodeLinkCount.get(link.to) || 0) + 1); // Count being targeted with less weight
    });
    
    const graphData = {
        nodes: Array.from(nodesSet).map(name => ({ 
            id: name, 
            name: name,
            linkCount: nodeLinkCount.get(name) || 0 // Store connection count
        })),
        links: monthData.map(d => ({
            source: d.from,
            target: d.to,
            value: d.count
        }))
    };
    
    console.log('Graph data processed:', graphData);

    // Update the visualization
    const maxLinkValue = d3.max(graphData.links, d => d.value);
    const minLinkValue = d3.min(graphData.links, d => d.value);
    const maxNodeCount = d3.max(graphData.nodes, n => n.linkCount);
    
    // More nuanced scales for visual elements
    const linkWidthScale = d3.scaleLinear()
        .domain([minLinkValue, maxLinkValue])
        .range([0.7, 4]); // Wider range for more visual distinction
        
    const linkOpacityScale = d3.scaleLinear()
        .domain([minLinkValue, maxLinkValue])
        .range([0.2, 0.8]); // More opacity contrast
        
    const nodeRadiusScale = d3.scaleSqrt() // Square root scale for better area representation
        .domain([0, maxNodeCount])
        .range([nodeRadius * 0.7, nodeRadius * 1.3]); // Size variance based on connections
        
    // Color palette variations for link strength
    const linkColorScale = d3.scaleLinear()
        .domain([minLinkValue, maxLinkValue])
        .range(['#e6e6e6', '#a0a0a0']); // Light to medium gray for strength

    // Clear previous elements
    svg.selectAll('*').remove();
    
    // Re-append the defs with marker
    const defs = svg.append('defs');
    
    // Create minimalist arrowhead marker
    defs.append('marker')
        .attr('id', 'arrowhead')
        .attr('viewBox', '0 -3 6 6')
        .attr('refX', nodeRadius + 5)
        .attr('refY', 0)
        .attr('markerWidth', 4)
        .attr('markerHeight', 4)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-3L6,0L0,3')
        .attr('class', 'arrowhead');

    // Create links with weight-based styling
    const linksSelection = svg.append('g')
        .attr('class', 'links')
        .selectAll('line')
        .data(graphData.links)
        .enter()
        .append('line')
        .attr('class', 'link')
        .style('stroke', d => linkColorScale(d.value)) // Color based on weight
        .style('stroke-opacity', d => linkOpacityScale(d.value)) // Opacity based on weight
        .style('stroke-width', d => linkWidthScale(d.value)); // Width based on weight

    // Create nodes group with minimal, modern design without hover effects
    const nodesSelection = svg.append('g')
        .attr('class', 'nodes')
        .selectAll('.node')
        .data(graphData.nodes)
        .enter()
        .append('g')
        .attr('class', 'node')
        .call(d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended));

    // Add clean, minimal node design
    nodesSelection.append('circle')
        .attr('r', nodeRadius)
        .style('fill', d => colors(d.id))
        .style('stroke', '#ffffff')
        .style('stroke-width', 1.5)
        .style('opacity', 0.85);

    // Add minimalist labels with just initials for even cleaner look
    nodesSelection.append('text')
        .attr('dy', '.4em')
        .attr('text-anchor', 'middle')
        .text(d => {
            const names = d.name.split(' ');
            return names.map(name => name[0]).join('');
        })
        .style('fill', '#ffffff')
        .style('font-weight', '500')
        .style('font-size', '11px')
        .style('font-family', "'Inter', sans-serif")
        .style('pointer-events', 'none');

    // Define the tick function - with no hover interactions
    function ticked() {
        // Keep nodes within bounds
        graphData.nodes.forEach(node => {
            node.x = Math.max(nodeRadius, Math.min(width - nodeRadius, node.x || width/2));
            node.y = Math.max(nodeRadius, Math.min(height - nodeRadius, node.y || height/2));
        });
        
        // Update link positions
        linksSelection
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);

        // Update node positions
        nodesSelection
            .attr('transform', d => `translate(${d.x},${d.y})`);
    }

    // Set fixed initial positions for nodes in a more distributed pattern
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) * 0.35; // Slightly larger radius
    
    graphData.nodes.forEach((node, i) => {
        // Randomize the positions slightly for a more organic feel
        const angle = (i / graphData.nodes.length) * 2 * Math.PI;
        const distanceVariation = 0.85 + Math.random() * 0.3; // Between 0.85 and 1.15
        node.x = centerX + radius * distanceVariation * Math.cos(angle);
        node.y = centerY + radius * distanceVariation * Math.sin(angle);
    });

    // Stop any ongoing simulation
    simulation.stop();
    
    // Update simulation with new data
    simulation.nodes(graphData.nodes);
    simulation.force('link').links(graphData.links);
    
    // Set up the tick event
    simulation.on('tick', ticked);
    
    // Call tick once to position elements immediately
    ticked();
    
    // Restart the simulation with high energy
    simulation.alpha(1).restart();
    
    console.log('Simulation restarted with nodes:', graphData.nodes.length);
    
    // Update the table
    updateCollaborationTable(monthData);
}

function updateCollaborationTable(data) {
    const tableBody = document.getElementById('collaborationTableBody');
    tableBody.innerHTML = ''; // Clear previous content
    
    data.forEach(item => {
        const row = document.createElement('tr');
        
        const fromCell = document.createElement('td');
        fromCell.textContent = item.from;
        row.appendChild(fromCell);
        
        const toCell = document.createElement('td');
        toCell.textContent = item.to;
        row.appendChild(toCell);
        
        const countCell = document.createElement('td');
        countCell.textContent = item.count;
        row.appendChild(countCell);
        
        const statusCell = document.createElement('td');
        let badgeClass, statusText;
        if (item.count >= 12) {
            badgeClass = 'bg-success';
            statusText = 'High';
        } else if (item.count >= 8) {
            badgeClass = 'bg-info';
            statusText = 'Medium';
        } else {
            badgeClass = 'bg-warning';
            statusText = 'Low';
        }
        
        const badge = document.createElement('span');
        badge.className = `badge ${badgeClass}`;
        badge.textContent = statusText;
        statusCell.appendChild(badge);
        
        row.appendChild(statusCell);
        tableBody.appendChild(row);
    });
}

// Initialize with sorted months and create slider markers
document.addEventListener('DOMContentLoaded', function() {
    const months = Object.keys(collaborationData).sort();
    console.log('Available months:', months);
    const mostRecentMonth = months.length > 0 ? months[months.length - 1] : null;
    console.log('Most recent month:', mostRecentMonth);

    // Set up the date slider
    const slider = document.getElementById('dateSlider');
    const sliderTrack = document.getElementById('dateSliderTrack');
    const currentPeriodEl = document.getElementById('currentPeriod');

    if (!slider || !sliderTrack || !currentPeriodEl) {
        console.error('Required elements not found');
        return;
    }

    // Configure the slider
    slider.min = 0;
    slider.max = months.length - 1;
    slider.value = months.length - 1; // Start with most recent month

    // Create date markers
    months.forEach((month, index) => {
        const marker = document.createElement('div');
        marker.className = 'date-marker';
        marker.style.left = `${(index / (months.length - 1)) * 100}%`;
        
        const label = document.createElement('div');
        label.className = 'date-label';
        label.textContent = month;
        
        marker.appendChild(label);
        sliderTrack.appendChild(marker);
    });

    // Update network when slider changes
    slider.addEventListener('input', function() {
        const index = parseInt(this.value);
        const selectedMonth = months[index];
        currentPeriodEl.textContent = selectedMonth;
        updateNetwork(collaborationData[selectedMonth]);
        
        // Update active marker
        document.querySelectorAll('.date-marker').forEach((marker, i) => {
            if (i === index) {
                marker.classList.add('active');
            } else {
                marker.classList.remove('active');
            }
        });
    });

    // Initialize with selected month
    if (mostRecentMonth) {
        currentPeriodEl.textContent = mostRecentMonth;
        updateNetwork(collaborationData[mostRecentMonth]);
        
        // Highlight the most recent marker
        const lastIndex = months.length - 1;
        const markers = document.querySelectorAll('.date-marker');
        if (markers.length > lastIndex) {
            markers[lastIndex].classList.add('active');
        }
    } else {
        console.error('No months available in the data');
    }
});
</script>

<style>
.arrowhead {
    fill: #d9d9d9;
    stroke: none;
}

.legend i {
    font-size: 0.8em;
    margin-right: 0.3em;
}

/* Remove hover cursor since we're removing interactions */
.node {
    cursor: default;
}

/* Clean background with very subtle pattern */
#networkGraph {
    background-color: #fafafa;
    background-image: radial-gradient(#e0e0e0 1px, transparent 1px);
    background-size: 50px 50px;
    border: none;
}

/* Update legend style to match modern design */
.legend {
    font-size: 0.9em;
    color: #666;
    letter-spacing: 0.02em;
}

/* Modern card styling */
.card {
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    border: none;
}

.card-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: #333;
}

/* Date slider styling */
#dateSliderContainer {
    height: 60px;
    padding: 10px 0;
}

#dateSliderTrack {
    background-color: #f0f0f0;
    border-radius: 4px;
    position: relative;
}

.date-marker {
    position: absolute;
    top: 0;
    width: 2px;
    height: 10px;
    background-color: #ccc;
    transform: translateX(-50%);
    transition: all 0.2s ease;
}

.date-marker.active {
    background-color: #2a9d8f;
    height: 16px;
}

.date-label {
    position: absolute;
    top: 18px;
    left: 0;
    transform: translateX(-50%);
    font-size: 0.7rem;
    color: #888;
    white-space: nowrap;
}

.date-marker.active .date-label {
    color: #2a9d8f;
    font-weight: 600;
}

/* Custom range input styling */
input[type=range] {
    -webkit-appearance: none;
    appearance: none;
    height: 5px;
    background: transparent;
    cursor: pointer;
}

input[type=range]:focus {
    outline: none;
}

input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #2a9d8f;
    border: 2px solid white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    cursor: grab;
}

input[type=range]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #2a9d8f;
    border: 2px solid white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    cursor: grab;
}

input[type=range]:active::-webkit-slider-thumb {
    cursor: grabbing;
}

input[type=range]:active::-moz-range-thumb {
    cursor: grabbing;
}
</style>
{% endblock %}
